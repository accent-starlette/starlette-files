{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This package's primary purpose is for handling files and the storage of those files. It uses SQLAlchemy as it's method of storing a reference to where those files are located within the given storage. There are currently two different types of storage. Amazon's S3 Simple Storage and a local file system storage. In addition to this there is additional functionality when dealing specifically with images. This includes operations such as resizing, cropping and changing the file format. This is without changing the original file. Getting Started - Installation This package has not been published to PyPI so you will need to install it from this repo . To do this simply run: pip install git+https://github.com/accent-starlette/starlette-files.git@master#egg=starlette-files The minimum Python requirement is 3.7.","title":"Introduction"},{"location":"#introduction","text":"This package's primary purpose is for handling files and the storage of those files. It uses SQLAlchemy as it's method of storing a reference to where those files are located within the given storage. There are currently two different types of storage. Amazon's S3 Simple Storage and a local file system storage. In addition to this there is additional functionality when dealing specifically with images. This includes operations such as resizing, cropping and changing the file format. This is without changing the original file.","title":"Introduction"},{"location":"#getting-started-installation","text":"This package has not been published to PyPI so you will need to install it from this repo . To do this simply run: pip install git+https://github.com/accent-starlette/starlette-files.git@master#egg=starlette-files The minimum Python requirement is 3.7.","title":"Getting Started - Installation"},{"location":"example/","text":"Example We have built a sample media library using this package that can be found in our boilerplate repo. The branch is called gallery and can be launched in docker. You will need to follow the readme to generate your migrations and create a user. Then login and visit http://localhost/admin.","title":"Example"},{"location":"example/#example","text":"We have built a sample media library using this package that can be found in our boilerplate repo. The branch is called gallery and can be launched in docker. You will need to follow the readme to generate your migrations and create a user. Then login and visit http://localhost/admin.","title":"Example"},{"location":"handling_files/","text":"Handling Files Now you have decided on the storage its time to start saving files. The first thing to do it to setup an attachment class. This is the SQLAlchemy field that stores the info for the file including its location in the storage. It is also what interacts between the table and the storage to save and retrieve the files. from starlette_files.constants import MB from starlette_files.fields import FileAttachment class FileType ( FileAttachment ): # your storage storage = my_storage # directory in the stroage to save files to directory = \"files\" # allowed content types allowed_content_types = [ \"application/pdf\" ] # maximum allowed size in bytes max_length = MB * 5 About content types To determine if the content type is allowed we use a package called python-magic . This identifies file types by checking their headers according to a predefined list of file types. This guards against the likes of someone renaming a .exe to a .pdf. This should be able to detect the file is infact an exe and will raise an exception if not valid. Please read their docs on installation as you will need additional os dependencies. Next setup your table to include the field: import sqlalchemy as sa class File ( Base ): file = sa . Column ( FileType . as_mutable ( sa . JSON )) Saving Files async def post ( request ): form = await request . form () session = Session () file_obj = FileType . create_from ( file = form [ \"file\" ] . file , original_filename = form [ \"file\" ] . filename ) instance = File ( file = file_obj ) session . add ( instance ) session . commit () # return your response An example form: < form method = \"post\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"file\" required > < input type = \"submit\" value = \"Submit\" > </ form > Working with Files A FileAttachment is a sqlalchemy.ext.mutable.MutableDict and therefore stores JSON as its value in the database. An example of this is: >>> instance = session.query ( File ) .first () >>> instance.file { 'original_filename' : 'example.pdf' , 'uploaded_on' : 1576792678 , 'content_type' : 'application/pdf' , 'extension' : '.pdf' , 'file_size' : 2897 , 'saved_filename' : '9fabf09a-d915-48e5-8775-4f553c571a0b.pdf' } Each of the above has a property too so you can just do: >>> instance.file.original_filename 'example.pdf' Additional properties include: @property def path ( self ) -> str : \"\"\" the path located within the storage if the directory on the FileAttachment is 'files' and the saved_filename is 'foo.txt' this will be 'files/foo.txt' \"\"\" @property def locate ( self ) -> str : \"\"\" this differs between storages and uses .path to get the file. using .path allows you to move the files to a different storage and as long as they live in the same path the rest will work as usual. for the filesystem storage this is the full file path on the system ie: /storage-path/files/foo.txt for the s3 storage its the url to access the file ie: https://bucket.s3.....storage-path/files/foo.txt \"\"\" @property def open ( self ) -> typing . IO : \"\"\" opens the file with file.open as f: # do something with f \"\"\"","title":"Handling Files"},{"location":"handling_files/#handling-files","text":"Now you have decided on the storage its time to start saving files. The first thing to do it to setup an attachment class. This is the SQLAlchemy field that stores the info for the file including its location in the storage. It is also what interacts between the table and the storage to save and retrieve the files. from starlette_files.constants import MB from starlette_files.fields import FileAttachment class FileType ( FileAttachment ): # your storage storage = my_storage # directory in the stroage to save files to directory = \"files\" # allowed content types allowed_content_types = [ \"application/pdf\" ] # maximum allowed size in bytes max_length = MB * 5 About content types To determine if the content type is allowed we use a package called python-magic . This identifies file types by checking their headers according to a predefined list of file types. This guards against the likes of someone renaming a .exe to a .pdf. This should be able to detect the file is infact an exe and will raise an exception if not valid. Please read their docs on installation as you will need additional os dependencies. Next setup your table to include the field: import sqlalchemy as sa class File ( Base ): file = sa . Column ( FileType . as_mutable ( sa . JSON ))","title":"Handling Files"},{"location":"handling_files/#saving-files","text":"async def post ( request ): form = await request . form () session = Session () file_obj = FileType . create_from ( file = form [ \"file\" ] . file , original_filename = form [ \"file\" ] . filename ) instance = File ( file = file_obj ) session . add ( instance ) session . commit () # return your response An example form: < form method = \"post\" enctype = \"multipart/form-data\" > < input type = \"file\" name = \"file\" required > < input type = \"submit\" value = \"Submit\" > </ form >","title":"Saving Files"},{"location":"handling_files/#working-with-files","text":"A FileAttachment is a sqlalchemy.ext.mutable.MutableDict and therefore stores JSON as its value in the database. An example of this is: >>> instance = session.query ( File ) .first () >>> instance.file { 'original_filename' : 'example.pdf' , 'uploaded_on' : 1576792678 , 'content_type' : 'application/pdf' , 'extension' : '.pdf' , 'file_size' : 2897 , 'saved_filename' : '9fabf09a-d915-48e5-8775-4f553c571a0b.pdf' } Each of the above has a property too so you can just do: >>> instance.file.original_filename 'example.pdf' Additional properties include: @property def path ( self ) -> str : \"\"\" the path located within the storage if the directory on the FileAttachment is 'files' and the saved_filename is 'foo.txt' this will be 'files/foo.txt' \"\"\" @property def locate ( self ) -> str : \"\"\" this differs between storages and uses .path to get the file. using .path allows you to move the files to a different storage and as long as they live in the same path the rest will work as usual. for the filesystem storage this is the full file path on the system ie: /storage-path/files/foo.txt for the s3 storage its the url to access the file ie: https://bucket.s3.....storage-path/files/foo.txt \"\"\" @property def open ( self ) -> typing . IO : \"\"\" opens the file with file.open as f: # do something with f \"\"\"","title":"Working with Files"},{"location":"handling_images/","text":"Handling Images The basics of handling images is the same as handling files. The only difference is that you will need to inherit from ImageAttachment instead of FileAttachment . Using the ImageAttachment An additional package is required when using images called pillow . to include this run: pip install git+https://github.com/accent-starlette/starlette-files.git@master#egg=starlette-files[image] from starlette_files.constants import MB from starlette_files.fields import ImageAttachment class ImageType ( ImageAttachment ): # your storage storage = my_storage # directory in the stroage to save files to directory = \"images\" # allowed content types allowed_content_types = [ \"image/jpeg\" , \"image/png\" ] # maximum allowed size in bytes max_length = MB * 5 And define your table: import sqlalchemy as sa class Image ( Base ): image = sa . Column ( ImageType . as_mutable ( sa . JSON )) Working with Images The only difference here is that it saves two additional bits of data, the width and the height of the image: >>> instance = session.query ( Image ) .first () >>> instance.image { 'original_filename' : 'example.png' , 'uploaded_on' : 1576792678 , 'content_type' : 'image/png' , 'extension' : '.png' , 'file_size' : 2897 , 'saved_filename' : '9fabf09a-d915-48e5-8775-4f553c571a0b.png' , 'width' : 800 , 'height' : 600 , } These both also include properties: >>> instance.image.width 800 Focal Point On an ImageAttachment you can also specify a focal point. This is the area of the image that is most important. To set this you can do: >>> instance.image.focal_point_x = 100 # px from the left >>> instance.image.focal_point_y = 100 # px from the top >>> instance.image.focal_point_width = 100 # width >>> instance.image.focal_point_height = 100 # height This is useful when dealing with image operations such as the fill operation .","title":"Handling Images"},{"location":"handling_images/#handling-images","text":"The basics of handling images is the same as handling files. The only difference is that you will need to inherit from ImageAttachment instead of FileAttachment . Using the ImageAttachment An additional package is required when using images called pillow . to include this run: pip install git+https://github.com/accent-starlette/starlette-files.git@master#egg=starlette-files[image] from starlette_files.constants import MB from starlette_files.fields import ImageAttachment class ImageType ( ImageAttachment ): # your storage storage = my_storage # directory in the stroage to save files to directory = \"images\" # allowed content types allowed_content_types = [ \"image/jpeg\" , \"image/png\" ] # maximum allowed size in bytes max_length = MB * 5 And define your table: import sqlalchemy as sa class Image ( Base ): image = sa . Column ( ImageType . as_mutable ( sa . JSON ))","title":"Handling Images"},{"location":"handling_images/#working-with-images","text":"The only difference here is that it saves two additional bits of data, the width and the height of the image: >>> instance = session.query ( Image ) .first () >>> instance.image { 'original_filename' : 'example.png' , 'uploaded_on' : 1576792678 , 'content_type' : 'image/png' , 'extension' : '.png' , 'file_size' : 2897 , 'saved_filename' : '9fabf09a-d915-48e5-8775-4f553c571a0b.png' , 'width' : 800 , 'height' : 600 , } These both also include properties: >>> instance.image.width 800","title":"Working with Images"},{"location":"handling_images/#focal-point","text":"On an ImageAttachment you can also specify a focal point. This is the area of the image that is most important. To set this you can do: >>> instance.image.focal_point_x = 100 # px from the left >>> instance.image.focal_point_y = 100 # px from the top >>> instance.image.focal_point_width = 100 # width >>> instance.image.focal_point_height = 100 # height This is useful when dealing with image operations such as the fill operation .","title":"Focal Point"},{"location":"image_operations/","text":"Image Operations Before you continue This section assumes you have worked through handling images and that you have your image model setup using an ImageAttachment class. About Operations Lets say you have a bunch of images of random sizes and image formats such as JPEG and PNG , but you want a consistent file output of say 100x100 and all PNG . Thats is the purpose of these operations. They take an image, use pillow to transform the image based on filters you specify and save a new version of the file. Getting Started You have your ImageAttachment class and Image table like below: import sqlalchemy as sa from starlette_files.constants import MB from starlette_files.fields import ImageAttachment class ImageType ( ImageAttachment ): # your storage storage = my_storage # directory in the stroage to save files to directory = \"images\" # allowed content types allowed_content_types = [ \"image/jpeg\" , \"image/png\" ] # maximum allowed size in bytes max_length = MB * 5 class Image ( Base ): image = sa . Column ( ImageType . as_mutable ( sa . JSON )) Next create another SQLAlchemy field that uses ImageRenditionAttachment . This class uses an instance of an ImageAttachment and has functionality to apply operations on the file before being saved to the storage. from starlette_files.fields import ImageRenditionAttachment class ImageRenditionType ( ImageRenditionAttachment ): storage = my_storage directory = \"renditions\" and create another table to store the images: class ImageRendition ( Base ): image = sa . Column ( ImageRenditionType . as_mutable ( sa . JSON )) original_image_id = sa . Column ( sa . Integer , sa . ForeignKey ( \"image.id\" ), nullable = False ) original_image = sa . orm . relationship ( \"Image\" , backref = \"renditions\" ) Creating a Rendition Once you have an instance of your Image : original_image = session . query ( Image ) . first () you can create a new rendition of it using a filter: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"width-100\" ] ) This will take the original image and make it 100px wide. You can then save it as normal: session = Session () instance = ImageRendition ( image = rendition_obj , original_image = original_image ) session . add ( instance ) session . commit () Filters Below are the pre-existing filter operations. Crop This allows you to take an image and crop it to a certain size. The format required for this is: f \"crop- { left } x { top } x { width } x { height } \" For example an image of 200x200 that you want to crop to 100x100 in the center would be: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"crop-50x50x100x100\" ] ) Do Nothing This as it sounds does nothing to the image and is useful if you want to still create the rendition but you do not want to change the image. The format required for this is: f \"original\" For example an image of 200x200 then you want to remain unchanged is: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"original\" ] ) Fill Resize and crop to fill the exact dimensions specified. This can be particularly useful for websites requiring square thumbnails of arbitrary images. For example, a landscape image of width 2000 and height 1000 treated with the fill200x200 rule would have its height reduced to 200, then its width (ordinarily 400) cropped to 200. This resize-rule will crop to the image\u2019s focal point if it has been set. If not, it will crop to the centre of the image.. The format required for this is: f \"fill- { width } x { height } \" On images that won\u2019t upscale It\u2019s possible to request an image with fill dimensions that the image can\u2019t support without upscaling. e.g. an image of width 400 and height 200 requested with fill-400x400. In this situation the ratio of the requested fill will be matched, but the dimension will not. So that example 400x200 image (a 2:1 ratio) could become 200x200 (a 1:1 ratio, matching the resize-rule). For example an image of 200x200 then you want to fill a 200x100 space is: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"fill-200x100\" ] ) Cropping closer to the focal point By default, we will only crop enough to change the aspect ratio of the image to match the ratio in the resize-rule. In some cases (e.g. thumbnails), it may be preferable to crop closer to the focal point, so that the subject of the image is more prominent. You can do this by appending -c<percentage> at the end of the resize-rule. For example, if you would like the image to be cropped as closely as possible to its focal point, add -c100 : f \"fill- { width } x { height } -c100\" This will crop the image as much as it can, without cropping into the focal point. If you find that -c100 is too close, you can try -c75 or -c50 . Any whole number from 0 to 100 is accepted. Format This is an operation that will change the format of the file. You can only use either jpeg or png . The format required for this is: f \"format- { format } \" For example an image of png then you want to save as a jpeg is: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"format-jpeg\" ] ) Min and Max [min] This is to basically cover the given dimensions. This may result in an image slightly larger than the dimensions you specify. A square image of width 2000 and height 2000, treated with the min-500x200 operation would have its height and width changed to 500, i.e matching the width of the resize-rule, but greater than the height. The format required for this is: f \"min- { width } x { height } \" [max] Fit within the given dimensions. The longest edge will be reduced to the matching dimension specified. For example, a portrait image of width 1000 and height 2000, treated with the max-1000x500 rule (a landscape layout) would result in the image being shrunk so the height was 500 pixels and the width was 250. The format required for this is: f \"max- { width } x { height } \" Scale The scale operation reduces the image in size by the percentage specified. The format required for this is: f \"scale- { percent } \" For example an image of 200x100 that you scale to 50 would end up 100x50: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"scale-50\" ] ) Width and Height [width] Reduces the width of the image to the dimension specified. The format required for this is: f \"width- { width } \" [height] Reduces the height of the image to the dimension specified. The format required for this is: f \"height- { height } \"","title":"Image Operations"},{"location":"image_operations/#image-operations","text":"Before you continue This section assumes you have worked through handling images and that you have your image model setup using an ImageAttachment class.","title":"Image Operations"},{"location":"image_operations/#about-operations","text":"Lets say you have a bunch of images of random sizes and image formats such as JPEG and PNG , but you want a consistent file output of say 100x100 and all PNG . Thats is the purpose of these operations. They take an image, use pillow to transform the image based on filters you specify and save a new version of the file.","title":"About Operations"},{"location":"image_operations/#getting-started","text":"You have your ImageAttachment class and Image table like below: import sqlalchemy as sa from starlette_files.constants import MB from starlette_files.fields import ImageAttachment class ImageType ( ImageAttachment ): # your storage storage = my_storage # directory in the stroage to save files to directory = \"images\" # allowed content types allowed_content_types = [ \"image/jpeg\" , \"image/png\" ] # maximum allowed size in bytes max_length = MB * 5 class Image ( Base ): image = sa . Column ( ImageType . as_mutable ( sa . JSON )) Next create another SQLAlchemy field that uses ImageRenditionAttachment . This class uses an instance of an ImageAttachment and has functionality to apply operations on the file before being saved to the storage. from starlette_files.fields import ImageRenditionAttachment class ImageRenditionType ( ImageRenditionAttachment ): storage = my_storage directory = \"renditions\" and create another table to store the images: class ImageRendition ( Base ): image = sa . Column ( ImageRenditionType . as_mutable ( sa . JSON )) original_image_id = sa . Column ( sa . Integer , sa . ForeignKey ( \"image.id\" ), nullable = False ) original_image = sa . orm . relationship ( \"Image\" , backref = \"renditions\" )","title":"Getting Started"},{"location":"image_operations/#creating-a-rendition","text":"Once you have an instance of your Image : original_image = session . query ( Image ) . first () you can create a new rendition of it using a filter: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"width-100\" ] ) This will take the original image and make it 100px wide. You can then save it as normal: session = Session () instance = ImageRendition ( image = rendition_obj , original_image = original_image ) session . add ( instance ) session . commit ()","title":"Creating a Rendition"},{"location":"image_operations/#filters","text":"Below are the pre-existing filter operations.","title":"Filters"},{"location":"image_operations/#crop","text":"This allows you to take an image and crop it to a certain size. The format required for this is: f \"crop- { left } x { top } x { width } x { height } \" For example an image of 200x200 that you want to crop to 100x100 in the center would be: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"crop-50x50x100x100\" ] )","title":"Crop"},{"location":"image_operations/#do-nothing","text":"This as it sounds does nothing to the image and is useful if you want to still create the rendition but you do not want to change the image. The format required for this is: f \"original\" For example an image of 200x200 then you want to remain unchanged is: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"original\" ] )","title":"Do Nothing"},{"location":"image_operations/#fill","text":"Resize and crop to fill the exact dimensions specified. This can be particularly useful for websites requiring square thumbnails of arbitrary images. For example, a landscape image of width 2000 and height 1000 treated with the fill200x200 rule would have its height reduced to 200, then its width (ordinarily 400) cropped to 200. This resize-rule will crop to the image\u2019s focal point if it has been set. If not, it will crop to the centre of the image.. The format required for this is: f \"fill- { width } x { height } \"","title":"Fill"},{"location":"image_operations/#on-images-that-wont-upscale","text":"It\u2019s possible to request an image with fill dimensions that the image can\u2019t support without upscaling. e.g. an image of width 400 and height 200 requested with fill-400x400. In this situation the ratio of the requested fill will be matched, but the dimension will not. So that example 400x200 image (a 2:1 ratio) could become 200x200 (a 1:1 ratio, matching the resize-rule). For example an image of 200x200 then you want to fill a 200x100 space is: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"fill-200x100\" ] )","title":"On images that won\u2019t upscale"},{"location":"image_operations/#cropping-closer-to-the-focal-point","text":"By default, we will only crop enough to change the aspect ratio of the image to match the ratio in the resize-rule. In some cases (e.g. thumbnails), it may be preferable to crop closer to the focal point, so that the subject of the image is more prominent. You can do this by appending -c<percentage> at the end of the resize-rule. For example, if you would like the image to be cropped as closely as possible to its focal point, add -c100 : f \"fill- { width } x { height } -c100\" This will crop the image as much as it can, without cropping into the focal point. If you find that -c100 is too close, you can try -c75 or -c50 . Any whole number from 0 to 100 is accepted.","title":"Cropping closer to the focal point"},{"location":"image_operations/#format","text":"This is an operation that will change the format of the file. You can only use either jpeg or png . The format required for this is: f \"format- { format } \" For example an image of png then you want to save as a jpeg is: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"format-jpeg\" ] )","title":"Format"},{"location":"image_operations/#min-and-max","text":"[min] This is to basically cover the given dimensions. This may result in an image slightly larger than the dimensions you specify. A square image of width 2000 and height 2000, treated with the min-500x200 operation would have its height and width changed to 500, i.e matching the width of the resize-rule, but greater than the height. The format required for this is: f \"min- { width } x { height } \" [max] Fit within the given dimensions. The longest edge will be reduced to the matching dimension specified. For example, a portrait image of width 1000 and height 2000, treated with the max-1000x500 rule (a landscape layout) would result in the image being shrunk so the height was 500 pixels and the width was 250. The format required for this is: f \"max- { width } x { height } \"","title":"Min and Max"},{"location":"image_operations/#scale","text":"The scale operation reduces the image in size by the percentage specified. The format required for this is: f \"scale- { percent } \" For example an image of 200x100 that you scale to 50 would end up 100x50: rendition_obj = ImageRenditionType . create_from ( attachment = original_image . image , filter_specs = [ \"scale-50\" ] )","title":"Scale"},{"location":"image_operations/#width-and-height","text":"[width] Reduces the width of the image to the dimension specified. The format required for this is: f \"width- { width } \" [height] Reduces the height of the image to the dimension specified. The format required for this is: f \"height- { height } \"","title":"Width and Height"},{"location":"storages/","text":"Storages Firstly you will need to decide what type of storage to use. The storages primary function is to be able to put , open , locate and delete a file. File System Storage The file system storage simply uses the local file system to store the files. Firstly define the storage: from starlette_files.storages import FileSystemStorage my_storage = FileSystemStorage ( root_path = \"/path-to-storage\" ) S3 Storage The S3 storage uses an amazon S3 bucket to store its files. You will need an Amazon account and there is an additional fee to using the S3 service. For more details see here . You will need an IAM account that has access to your bucket. Using the S3Storage An additional package is required when using S3 called boto3 . to include this run: pip install git+https://github.com/accent-starlette/starlette-files.git@master#egg=starlette-files[s3] Once you have all this define the storage: from starlette_files.storages import S3Storage my_storage = S3Storage ( bucket = \"your-bucket-name\" , access_key = \"your-access-key\" , secret_key = \"your-secret-access-key\" , # region: the location of your bucket, i.e. eu-west-2 region = \"aws-region\" , # acl: whether the files should remain private, public-read etc # for further info see: # https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl # the default is private acl = \"public-read\" , # prefix: the root path of the storage ie \"/path-to-storage\" # default is None for the root of the bucket prefix = None , ) Rolling Your Own If your need to define your own storage your class should inherit from starlette_files.storages.Storage . The only defined methods can be seen below and all will need implementing: class Storage : \"\"\" The abstract base class for all stores. \"\"\" def put ( self , filename : str , stream : typing . IO ) -> int : \"\"\" Should be overridden in inherited class and puts the file-like object as the given filename in the store. :param filename: the target filename. :param stream: the source file-like object :return: length of the stored file. \"\"\" raise NotImplementedError () def delete ( self , filename : str ) -> None : \"\"\" Should be overridden in inherited class and deletes the given file. :param filename: The filename to delete \"\"\" raise NotImplementedError () def open ( self , filename : str , mode : str = \"rb\" ) -> typing . IO : \"\"\" Should be overridden in inherited class and return a file-like object representing the file in the store. :param filename: The filename to open. :param mode: same as the `mode` in famous :func:`.open` function. \"\"\" raise NotImplementedError () def locate ( self , filename : str ) -> str : \"\"\" If overridden in the inherited class, should locate the file's url to share in public space or a path of some sort to locate it. This method is not used internally by starlette-files it is just a handy helper that gets returned by an Attachment property. :param filename: The filename to locate. \"\"\" raise NotImplementedError ()","title":"Storages"},{"location":"storages/#storages","text":"Firstly you will need to decide what type of storage to use. The storages primary function is to be able to put , open , locate and delete a file.","title":"Storages"},{"location":"storages/#file-system-storage","text":"The file system storage simply uses the local file system to store the files. Firstly define the storage: from starlette_files.storages import FileSystemStorage my_storage = FileSystemStorage ( root_path = \"/path-to-storage\" )","title":"File System Storage"},{"location":"storages/#s3-storage","text":"The S3 storage uses an amazon S3 bucket to store its files. You will need an Amazon account and there is an additional fee to using the S3 service. For more details see here . You will need an IAM account that has access to your bucket. Using the S3Storage An additional package is required when using S3 called boto3 . to include this run: pip install git+https://github.com/accent-starlette/starlette-files.git@master#egg=starlette-files[s3] Once you have all this define the storage: from starlette_files.storages import S3Storage my_storage = S3Storage ( bucket = \"your-bucket-name\" , access_key = \"your-access-key\" , secret_key = \"your-secret-access-key\" , # region: the location of your bucket, i.e. eu-west-2 region = \"aws-region\" , # acl: whether the files should remain private, public-read etc # for further info see: # https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl # the default is private acl = \"public-read\" , # prefix: the root path of the storage ie \"/path-to-storage\" # default is None for the root of the bucket prefix = None , )","title":"S3 Storage"},{"location":"storages/#rolling-your-own","text":"If your need to define your own storage your class should inherit from starlette_files.storages.Storage . The only defined methods can be seen below and all will need implementing: class Storage : \"\"\" The abstract base class for all stores. \"\"\" def put ( self , filename : str , stream : typing . IO ) -> int : \"\"\" Should be overridden in inherited class and puts the file-like object as the given filename in the store. :param filename: the target filename. :param stream: the source file-like object :return: length of the stored file. \"\"\" raise NotImplementedError () def delete ( self , filename : str ) -> None : \"\"\" Should be overridden in inherited class and deletes the given file. :param filename: The filename to delete \"\"\" raise NotImplementedError () def open ( self , filename : str , mode : str = \"rb\" ) -> typing . IO : \"\"\" Should be overridden in inherited class and return a file-like object representing the file in the store. :param filename: The filename to open. :param mode: same as the `mode` in famous :func:`.open` function. \"\"\" raise NotImplementedError () def locate ( self , filename : str ) -> str : \"\"\" If overridden in the inherited class, should locate the file's url to share in public space or a path of some sort to locate it. This method is not used internally by starlette-files it is just a handy helper that gets returned by an Attachment property. :param filename: The filename to locate. \"\"\" raise NotImplementedError ()","title":"Rolling Your Own"}]}